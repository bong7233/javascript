# 함수 
- input과 output 있는 상태로 파이썬의 함수와 비슷하다 생각하자.
- 현업에선 함수만드는게 주 업무라고 할정도로 중요하다.
- 함수내에 미지수 x,y가 있다는건 외부로부터 값을 받아야함을 뜻한다
  - 이때 값을 받는것을 '호출'이라고 한다.(즉 함수가 호출되어진다)
  - 브라우저가 호출할때를 "비동기" 라고 함
```
function add(x,y){
    return x + y;
}

add(2,5); //7
```
- 다만 함수의 과정을 statement로 구현하고 코드블럭으로 감싸서 하나의 실행 단위로 정의
- 변수 parameter , 인수 argument, 반환값 return value/ 함수도 값이다
- 함수정의 function definition 를 통해 생성하며 다양한 방법이 있음
- 함수호출 function call/invoke 로 호출하여 실행을 명시적으로 지시해야함

## 함수사용 이유
- 코드의 재사용 및 유지보수 편의성, 신뢰성 향상
- 함수는 객체타입 값 -> 식별자를 붙일 수 있음(가독성)

## 함수 리터럴
- 함수도 객체타입 값이므로 함수리터럴로 생성가능
- function 키워드, 함수이름, 매개변수목록, 함수몸체 로 구성
### 함수이름
- 함수 이름은 식별자, 네이밍규칙준수
- 함수 몸체 내에서만 참조할 수 있는 식별자
- 이름은 생략가능, 이름이있으면 기명함수 named function, 없으면 익명/무명함수 anonymous function
### 매개변수 목록
- 0개이상의 매개변수를 소괄호로 감싸고 쉼표로 구분
- 함수 호출시 각 매개변수에는 지정인수가 순서대로 할당-> 매개변수 목록의 순서는 의미있음
- 매개변수는 몸체내에서 변수와 동일하게 취급 -> 매개변수도 식별자 네이밍규칙 준수
### 함수몸체
- 함수호출시 일괄적으로 실행될 문들을 하나의 실행단위로 정의한 코드블록
- 함수 호출에의해 실행
```
변수에 함수 리터럴 할당
var f = function add(x,y) {
    return x+y;
}
```
- 함수는 일반객체와다르게 **호출할 수 있다** 그리고 고유한 프로퍼티를 갖는다

## 함수 정의
- 함수를 호출하기 전 인수를 전달받을 매개변수,실행문,반환값을 지정하는것
- 정의된 함수는 자바스크립트 엔진에의해 평가되어 함수객체가된다
### 함수선언문 function declaration/statement
```
function add(x, y) {
  return x + y;
}
```
### 함수 표현식 function expression
```
var add = function (x, y) {
  return x + y;
};
```
### Function 생성자함수 function constructor
```
var add = new Function('x', 'y', 'return x + y');
```
### 화살표함수 arrow function -> ES6
```
var add = (x, y) => x + y;
```
```
선언과 정의 Declaration and Definition
선언은 그 선언한것에 들어갈 값에대한 메모리생성하지않음(선언자체의 메모리는있다)
정의는 선언한것에 값을 넣어서 메모리에 할당됨

변수는 선언/ 함수는 정의 임을 기억하자
```

## 함수선언문 사용
- 함수선언문은 함수리터럴과 형태가 동일하지만 함수리터럴은 함수이름생략가능/ 함수선언문은 함수이름 생략불가능
- 함수선언문은 표현식이 아닌 문-> 크롬에서 선언문실행하면 undefined 출력된다(만약 표현식인문이라면 생성된함수가 출력되는게정상)
- 하지만 상황에 따라 자바스크립트엔진이 기명함수 리터럴과 함수선언문을 스스로 판단하여 실행시키기도한다
- 함수 선언문으로 정의된 함수는 자바스크립트엔진은 함수선언문을 해석해 함수객체를 생성-> 이때 함수이름과 동일한이름의 식별자를 암묵적으로 생성하여 거기에 함수객체를 할당한다.(함수리터럴은 아님을 주의)
```
함수 선언문
function add(x, y) {
  return x + y;
}

함수 참조
console.dir은 console.log와는 달리 함수 객체의 프로퍼티까지 출력한다.
단, Node.js 환경에서는 console.log와 같은 결과가 출력된다.
console.dir(add); // ƒ add(x, y)

함수 호출
console.log(add(2, 5)); // 7
```

## 함수 표현식
- 함수=객체-값처럼 변수,프로퍼티,배열의 요소가될수있음= 일급객체다 first-class object
- So 함수리터럴로 생성한 함수객체를 변수에 할당하면? 함수표현식 이라함
- 함수 표현식의 함수리터럴은 함수이름을 생략하는것이 일반적(익명함수)
```
// 함수 표현식
var add = function (x, y) {  -< function plus(x,y)가 아니다 생략했다
  return x + y;
};

console.log(add(2, 5)); // 7
```
### 함수선언문은 표현식이아닌문/ 함수표현식은 표현식인문 임을 기억하자

## 함수생성시점과 함수 호이스팅
- 함수 표현식으로 정의한함수는 호이스팅 X
- 함수 선언문으로 정의한 함수는 호이스팅 O
- 함수선언문과 변수선언문은 호이스팅은 다르다
    - 변수호이스팅은 undefined로 초기화되고 함수호이스팅은 함수객체로 초기화된다-> 즉 선언문 이전에 변수를 참조하면 undefined로 평가되지만 함수를 참조하면 함수호출이 가능하다
- 함수표현식의 호이스팅은 또 다르다
    - 함수표현식은 변수할당문과 변수선언문을 동시에 동작하는것과같아서 변수 호이스팅처럼 동작한다. 즉 함수표현식 이전에 함수참조하면 undefined 평가된다.
- 그래서 결론은 함수선언문은 호이스팅의규칙을 어지럽히므로 사용을 지양/ 함수표현식을 사용하는것이 변수선언문과 똑같이 즉 일관성있게 작동하고 좋음

## Function 생성자 함수
- 자바스크립트 내장함수, 여기에 매개변수목록과 함수몸체를 문자열로 전달하면서 new연산자와함께 호출하면 함수객체를 생성해서 반환(new 연산자 없어도 결과는 동일)
```
생성자함수 constructor function
객체를 생성하는 함수, 생성방식은 객체리터럴 외 다양한 방법이있음 이후에 더 자세히공부
```
```
add함수만들기
var add = new Function('x', 'y', 'return x + y');

console.log(add(2, 5)); // 7
```
- 생성자함수로 함수를 생성하는것은 좋지않고 함수선언문이나 함수표현식으로 생성한 함수와는 평가결과가 다르다(참조오류가뜬다)

## 화살표함수
- ES6 에서 도입, function키워드대신 화살표 =>(fat arrow)를 사용(항상 익명함수로 정의)
- 화살표함수는 생성자함수로 사용불가능
```
화살표 함수
const add = (x, y) => x + y;
console.log(add(2, 5)); // 7
```

## 함수 호출
- 식별자 () 로 호출, 함수를 호출하면 현재 실행흐름 중단, 호출된 함수로 실행흐름 옮김
### 매개변수와 인수
- 필요한값을 외부에서 내부로 전달시 매개변수를 통해 인수를 전달(인수는 값으로 평가될수있는 표현식and 갯수와 타입에 제한없음)
- 함수가 호출되면 암묵적으로 매개변수 생성되고 변수처럼 undefined로 초기화 된 후 인수가 순서대로 할당
- 매개변수의 스코프는 함수내부
- 매개변수와 인수의 갯수가 일치하지않아도 인수가 할당되지않은 매개변수는 undefined로 할당되고 오류뜨지않음
- 인수가 초과되면 암묵적으로 arguments 객체의 프로퍼티로 보관됨
### 인수확인
- 자바스크립트는 동적언어-> 매개변수의 타입을 사전정의 불가
- 확인하려면 런타임에서 알수있으므로 이를 보완하는것이 타입스크립트(정적타입언어의 성질가짐)
- arguments 객체를 통해 인수개수를 확인가능, 단축평가로 기본값도할당가능
```
function add(a, b, c) {
  a = a || 0;
  b = b || 0;
  c = c || 0;
  return a + b + c;
}

console.log(add(1, 2, 3)); // 6
console.log(add(1, 2)); // 3
console.log(add(1)); // 1
console.log(add()); // 0
```
### 매개변수의 개수
- 클린한코드를위해선 매개변수는 적을수록, 가급적 3개이하로 하는것이 좋다( 함수가 한가지일만 하는것이 좋은코드다)
---

## 반환문
- return 키워드와 표현식(반환값)으로 이뤄진 반환문을 통해 실행결과를 외부로 반환
- 반환문 : 함수실행중단하고 함수몸체 빠져나가기, return키워드 뒤의 표현식을 평가해 반환(표현식을 지정하지않으면 undefined)
- 반환문은 생략가능하며 암묵적으로 undefined 반환
- return 과 표현식사이 줄바꿈이있으면 ASI에 의해 표현식이 무시됨을 주의
- Node.js는 파일별 독립적 파일스코프를 가지므로 가장 바깥영역에서 반환문사용해도 문법에러 발생하지않음

## 참조에 의한 전달과 외부상태의 변경
- 매개변수도 함수몸체 내부에서 변수와 동일취급되므로 참조에의한 전달방식을 따름
- 함수호출시 매개변수에 값을 전달하는 방식을 값에의한호출,참조에의한호출로 구분하기도하지만 동작방식은 동일하다
- 즉 참조에의한호출은 다양한 부수효과를 가져오기떄문에 매개변수로 원시타입변수의 전달은 좋지만, 참조타입변수는 매우 불안정하다
- 순수함수란 이런 부수효과없이 외부의 상태를 변경하지않고 외부의상태에 영향도 받지않는 함수이다

## 다양한 함수형태
### 즉시실행함수
- 함수 정의와 동시에 즉시호출되는함수 (IIFE, Immediately Invoked Function Expression)/ 단 한번만 호출되며 다시호출 불가능(익명함수를 사용하는것이 일반적)
- 오류를 방지하기위해 즉시실행함수는 반드시 그룹연산자()로 감싸야한다
```
즉시 실행 함수도 일반 함수처럼 값을 반환할 수 있다.
var res = (function () {
  var a = 3;
  var b = 5;
  return a * b;
}());

console.log(res); // 15

즉시 실행 함수에도 일반 함수처럼 인수를 전달할 수 있다.
res = (function (a, b) {
  return a * b;
}(3, 5));

console.log(res); // 15
```
### 재귀함수
- 재귀호출 recursive call 자신을 호출함-> 반복처리
- 무한루프 빠질수있으므로 되도록이면 반복문을 사용
```
팩토리얼 재귀함수(1부터 자신까지의 모든 양의 정수의 곱)
// n! = 1 * 2 * ... * (n-1) * n
function factorial(n) {
  // 탈출 조건: n이 1 이하일 때 재귀 호출을 멈춘다.
  if (n <= 1) return 1;
  // 재귀 호출
  return n * factorial(n - 1);
}
console.log(factorial(3)); // 3! = 3 * 2 * 1 = 6
console.log(factorial(4)); // 4! = 4 * 3 * 1 * 1 = 24
console.log(factorial(5)); // 5! = 5 * 4 * 3 * 2 * 1 = 120
```
### 중첩함수 nested function/ 내부함수 inner function
- 함수의 내부에 정의된함수(중첩함수를 포함하는함수는 외부함수 outer function) / 일반적으로 중첩함수는 외부함수를돕는 헬퍼함수(helper function)의 역할을 함
- ES6 부터는 문이 위치할수 있는 문맥이라면 어디든지 가능(if,for문의 코드블록 내에서도 가능하다 but 호이스팅으로 혼란발생...)
### 콜백함수
- 콜백함수 callback function : 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수
- 고차함수 Higher-Order Finction, HOF : 매개변수를 통해 함수의 외부에서 콜백함수를 전달받은함수 
- 즉 콜백함수는 고차함수에 일부분으로 들어가서 헬퍼함수역할을 함(중첩함수는 고정되어있어 교체가 힘들지만, 콜백함수는 외부에서 고차함수 내부로 합성되므로 자유롭게 교체할수있다는 장점)
- 비동기처리 및 배열 고차함수에도 사용
```
// 콜백 함수를 사용하는 고차 함수 map
var res = [1, 2, 3].map(function (item) {
  return item * 2;
});

console.log(res); // [2, 4, 6]

// 콜백 함수를 사용하는 고차 함수 filter
res = [1, 2, 3].filter(function (item) {
  return item % 2;
});

console.log(res); // [1, 3]

// 콜백 함수를 사용하는 고차 함수 reduce
res = [1, 2, 3].reduce(function (acc, cur) {
  return acc + cur;
}, 0);

console.log(res); // 6
```
### 순수함수와 비순수함수
- 순수함수 pure function : 외부상태 의존 X 변경 X
- 비순수함수 impure function : 외부상태 의존, 외부상태 변경(부수효과 on)






















