# 함수 
- input과 output 있는 상태로 파이썬의 함수와 비슷하다 생각하자.
```
function add(x,y){
    return x + y;
}

add(2,5); //7
```
- 다만 함수의 과정을 statement로 구현하고 코드블럭으로 감싸서 하나의 실행 단위로 정의
- 변수 parameter , 인수 argument, 반환값 return value/ 함수도 값이다
- 함수정의 function definition 를 통해 생성하며 다양한 방법이 있음
- 함수호출 function call/invoke 로 호출하여 실행을 명시적으로 지시해야함

## 함수사용 이유
- 코드의 재사용 및 유지보수 편의성, 신뢰성 향상
- 함수는 객체타입 값 -> 식별자를 붙일 수 있음(가독성)

## 함수 리터럴
- 함수도 객체타입 값이므로 함수리터럴로 생성가능
- function 키워드, 함수이름, 매개변수목록, 함수몸체 로 구성
### 함수이름
- 함수 이름은 식별자, 네이밍규칙준수
- 함수 몸체 내에서만 참조할 수 있는 식별자
- 이름은 생략가능, 이름이있으면 기명함수 named function, 없으면 익명/무명함수 anonymous function
### 매개변수 목록
- 0개이상의 매개변수를 소괄호로 감싸고 쉼표로 구분
- 함수 호출시 각 매개변수에는 지정인수가 순서대로 할당-> 매개변수 목록의 순서는 의미있음
- 매개변수는 몸체내에서 변수와 동일하게 취급 -> 매개변수도 식별자 네이밍규칙 준수
### 함수몸체
- 함수호출시 일괄적으로 실행될 문들을 하나의 실행단위로 정의한 코드블록
- 함수 호출에의해 실행
```
변수에 함수 리터럴 할당
var f = function add(x,y) {
    return x+y;
}
```
- 함수는 일반객체와다르게 **호출할 수 있다** 그리고 고유한 프로퍼티를 갖는다

## 함수 정의
- 함수를 호출하기 전 인수를 전달받을 매개변수,실행문,반환값을 지정하는것
- 정의된 함수는 자바스크립트 엔진에의해 평가되어 함수객체가된다
### 함수선언문 function declaration/statement
```
function add(x, y) {
  return x + y;
}
```
### 함수 표현식 function expression
```
var add = function (x, y) {
  return x + y;
};
```
### Function 생성자함수 function constructor
```
var add = new Function('x', 'y', 'return x + y');
```
### 화살표함수 arrow function -> ES6
```
var add = (x, y) => x + y;
```
```
선언과 정의 Declaration and Definition
선언은 그 선언한것에 들어갈 값에대한 메모리생성하지않음(선언자체의 메모리는있다)
정의는 선언한것에 값을 넣어서 메모리에 할당됨

변수는 선언/ 함수는 정의 임을 기억하자
```

## 함수선언문 사용
- 함수선언문은 함수리터럴과 형태가 동일하지만 함수리터럴은 함수이름생략가능/ 함수선언문은 함수이름 생략불가능
- 함수선언문은 표현식이 아닌 문-> 크롬에서 선언문실행하면 undefined 출력된다(만약 표현식인문이라면 생성된함수가 출력되는게정상)
- 하지만 상황에 따라 자바스크립트엔진이 기명함수 리터럴과 함수선언문을 스스로 판단하여 실행시키기도한다
- 함수 선언문으로 정의된 함수는 자바스크립트엔진은 함수선언문을 해석해 함수객체를 생성-> 이때 함수이름과 동일한이름의 식별자를 암묵적으로 생성하여 거기에 함수객체를 할당한다.(함수리터럴은 아님을 주의)
```
함수 선언문
function add(x, y) {
  return x + y;
}

함수 참조
console.dir은 console.log와는 달리 함수 객체의 프로퍼티까지 출력한다.
단, Node.js 환경에서는 console.log와 같은 결과가 출력된다.
console.dir(add); // ƒ add(x, y)

함수 호출
console.log(add(2, 5)); // 7
```

## 함수 표현식
- 함수=객체-값처럼 변수,프로퍼티,배열의 요소가될수있음= 일급객체다 first-class object
- So 함수리터럴로 생성한 함수객체를 변수에 할당하면? 함수표현식 이라함
- 함수 표현식의 함수리터럴은 함수이름을 생략하는것이 일반적(익명함수)
```
// 함수 표현식
var add = function (x, y) {  -< function plus(x,y)가 아니다 생략했다
  return x + y;
};

console.log(add(2, 5)); // 7
```
### 함수선언문은 표현식이아닌문/ 함수표현식은 표현식인문 임을 기억하자

## 함수생성시점과 함수 호이스팅
- 함수 표현식으로 정의한함수는 호이스팅 X
- 함수 선언문으로 정의한 함수는 호이스팅 O
- 함수선언문과 변수선언문은 호이스팅은 다르다
    - 변수호이스팅은 undefined로 초기화되고 함수호이스팅은 함수객체로 초기화된다-> 즉 선언문 이전에 변수를 참조하면 undefined로 평가되지만 함수를 참조하면 함수호출이 가능하다
- 함수표현식의 호이스팅은 또 다르다
    - 함수표현식은 변수할당문과 변수선언문을 동시에 동작하는것과같아서 변수 호이스팅처럼 동작한다. 즉 함수표현식 이전에 함수참조하면 undefined 평가된다.
- 그래서 결론은 함수선언문은 호이스팅의규칙을 어지럽히므로 사용을 지양/ 함수표현식을 사용하는것이 변수선언문과 똑같이 즉 일관성있게 작동하고 좋음

## Function 생성자 함수
- 자바스크립트 내장함수, 여기에 매개변수목록과 함수몸체를 문자열로 전달하면서 new연산자와함께 호출하면 함수객체를 생성해서 반환(new 연산자 없어도 결과는 동일)
```
생성자함수 constructor function
객체를 생성하는 함수, 생성방식은 객체리터럴 외 다양한 방법이있음 이후에 더 자세히공부
```
```
add함수만들기
var add = new Function('x', 'y', 'return x + y');

console.log(add(2, 5)); // 7
```
- 생성자함수로 함수를 생성하는것은 좋지않고 함수선언문이나 함수표현식으로 생성한 함수와는 평가결과가 다르다(참조오류가뜬다)

## 화살표함수
- ES6 에서 도입, function키워드대신 화살표 =>(fat arrow)를 사용(항상 익명함수로 정의)
- 화살표함수는 생성자함수로 사용불가능
```
화살표 함수
const add = (x, y) => x + y;
console.log(add(2, 5)); // 7
```

##