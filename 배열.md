# 배열 array
- 여러개의 값을 순차적으로 나열한 자료구조
    - 배열은 타입이아니다, 객체 타입 이다
- 배열 내부의 값 : 요소 element (값으로 인정하는 모든것은 요소로 가능)
    - element 는 자신의 배열내 위치를 나타내는 index 가짐
    - index 는 element 에 접근할때 사용 , 0부터 시작
- 배열은 length 프로퍼티(배열의 길이 나타냄) 가짐
    - length 프로퍼티, index 를 활용하여 반복문으로 요소에 순차적접근 가능 한것이 가장큰 장점
- 배열생성
    - 배열리터럴
    - Array 생성자함수
    - Array.of , Array.from 메서드
- 배열의 생성자함수는 Array
- 배열의 프로토타입객체는 Array.prototype
    - Array.prototype 은 배열을위한 빌트인 메서드 제공

- 일반객체와 배열의 차이
<table>
  <thead>
    <tr>
      <th style="text-align: left">구분</th>
      <th style="text-align: center">객체</th>
      <th style="text-align: center">배열</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">구조</td>
      <td style="text-align: center">프로퍼티 키와 프로퍼티 값</td>
      <td style="text-align: center">인덱스와 요소</td>
    </tr>
    <tr>
      <td style="text-align: left">값의 참조</td>
      <td style="text-align: center">프로퍼티 키</td>
      <td style="text-align: center">인덱스</td>
    </tr>
    <tr>
      <td style="text-align: left">값의 순서</td>
      <td style="text-align: center">x</td>
      <td style="text-align: center">○</td>
    </tr>
    <tr>
      <td style="text-align: left">length 프로퍼티</td>
      <td style="text-align: center">x</td>
      <td style="text-align: center">○</td>
    </tr>
  </tbody>
</table>
  
---
</br> 

## 자바스크립트의 배열은 일반적인 배열과 다르다
- 자료구조에서의 배열은 ***밀집배열(dense array)***  
동일한 크기의 메모리공간이 빈틈없이 연속적으로 나열된 구조. 배열의 요소는 하나의 데이터타입으로 통일, 연속적
    - index를 통해 한번의 연산으로 요소에접근가능, O(1)
    - 하지만 정렬되지않은 배열이면? 처음부터 linear serch 해야함 O(n)
    - 요소 삽입,삭제도 연속성유지를 위해 요소를 이동시켜야함...bad
- 자바스크립트에서의 배열은 ***희소배열 (saparse array)***  
각각의 메모리크기는 달라도되고 비연속적이여도 됨. 배열의 동작을 흉내낸 **특수한 객체**
- 쉽게 이해하는 자바스크립트 배열구조?
    - 배열의 인덱스를 나타내는 문자열 ('0', '1', '2' ...) : 프로퍼티 키
    - 배열의 요소 : 프로퍼티 값(어떤값이라도 들어올수있음)
    - length 프로퍼티 가짐
    - 해시테이블 구조, 속도는 느리지만 요소 삽입,삭제가 편리하고 빠름
    - 느린속도를 보완하기위해 모던자바스크립트 엔진들은 최적화시켜서 극복
---
</br>

## length 프로퍼티와 희소배열
- length 프로퍼티 : 요소의 갯수, 빈배열은 0, 빈배열 아니면 가장큰요소의 인덱스 +1 (0부터시작하기때문)
- length 의 maximun은 2의32승
- 요소 추가,삭제시 자동 갱신
- 임의의 숫자값을 명시적으로 할당도 가능
    - 프로퍼티보다 적은값을 할당하면 자동으로 줄어듬
    - 프로퍼티보다 큰값을 할당하면 배열의 길이는 그대로, 프로퍼티 값은 변경(이때 빈자리는 메모리확보하지않고 그냥 비워두고 empty로 알려줌)
```
const arr = [1, 2, 3, 4, 5];

// 현재 length 프로퍼티 값인 5보다 작은 숫자 값 3을 length 프로퍼티에 할당
arr.length = 3;

// 배열의 길이가 5에서 3으로 줄어든다.
console.log(arr); // [1, 2, 3]

// 더 많은수인 6을할당
arr.length = 6;
console.log(arr); // [1,2,3, <3 empty items> ]
```
- 결론은 배열의 요소가 비연속적이고 일부가 비어있다? = 희소배열  
그래서 length와 배열요소의 개수가 불일치, 정확히는 length는 희소배열의 실제 요소개수보다 항상 크다
    - 그래서 쓰지않을수록 좋다... 배열에는 같은타입요소를 연속위치하는게 best
---
</br>

## 배열생성
---
### 배열 리터럴
- 가장 normal, easy
- 0개 이상 요소를 쉼포로 구분, [] 묶음, 프로퍼티키 없고 값만있음
    - const arr = [1,2,3];
### Array 생성자함수
- new 연산자 없어도 내부의 new.target이 확인되어 생성자함수로 동작함
- 전달된 인수 갯수에따라 다르게 동작함을 주의
    - 전달 1개 and 숫자 : 인수를 length프로퍼티값(내용은 비어있는 희소배열)
    - 전달 X : 빈배열 [] 생성 (배열리터럴 []와 같음)
    - 전달 2개이상 or 숫자가 아니면 : 인수를 요소로
### Array.of
- 인수를 요소로갖는 배열생성(ES6 에서 도입)
    - 인수 갯수상관없음
### Array.from
- 유사배열객체 or 이터러블객체를 인수로 받아서 배열로 변환후 반환
```
// 유사 배열 객체를 변환하여 배열을 생성한다.
Array.from({ length: 2, 0: 'a', 1: 'b' }); // -> ['a', 'b']

// 이터러블을 변환하여 배열을 생성한다. 문자열은 이터러블이다.
Array.from('Hello'); // -> ['H', 'e', 'l', 'l', 'o']
```
- 두번째 인수에 콜백함수 전달하면 파이썬의 map과 같은 효과로 배열생성
```
// Array.from에 length만 존재하는 유사 배열 객체를 전달하면 undefined를 요소로 채운다.
Array.from({ length: 3 }); // -> [undefined, undefined, undefined]

// Array.from은 두 번째 인수로 전달한 콜백 함수의 반환값으로 구성된 배열을 반환한다.
Array.from({ length: 3 }, (_, i) => i); // -> [0, 1, 2]
```
- 이터러블객체  
Symbol.iterator 메서드로 for..of문을 사용해 순회가능하며 스프레드문법과 배열디스트럭처링할당의 대상으로 사용가능한 객체 (아직은 무슨뜻인지모름)

## 배열요소의 참조
- 배열요소 참조시 대괄호표기법[] 사용
    - 대괄호 안에는 인덱스
    - 정수로 평가되는 표현식이라면? 인덱스 대신사용 가능
    - 인덱스는 객체의 프로퍼티와 같은역할(값을 참조할수있음)
    - 존재하지않는 요소 접근? undefined

## 배열요소의 추가와 갱신
- 존재하지않는 인덱스를 사용, 값 할당하면 새로운 요소로 추가(length 프로퍼티 자동갱신)
    - length 보다 큰인덱스로 요소추가? 희소배열 됨
    - 기존 요소에 값 재할당하면 갱신
    - 인덱스요소를 정수가 아닌걸로 추가? 요소생성이 아니고 프로퍼티생성됨(이떄 추가된 프로퍼티는 length값에 영향주지않음)
```
const arr = [];

// 배열 요소의 추가
arr[0] = 1;
arr['1'] = 2;

// 프로퍼티 추가
arr['foo'] = 3;
arr.bar = 4;
arr[1.1] = 5;
arr[-1] = 6;

console.log(arr); // [1, 2, foo: 3, bar: 4, '1.1': 5, '-1': 6]

// 프로퍼티는 length에 영향을 주지 않는다.
console.log(arr.length); // 2
```
## 배열요소 삭제
- 배열은 객체다, 요소삭제는 delete 연산자로 가능
    - why? delete는 프로퍼티를 삭제하므로
    - but delete 사용하면 일반 배열도 희소배열이 되버림 bad
- So Array.prototype.splice 메서드 사용
```
const arr = [1, 2, 3];

// Array.prototype.splice(삭제를 시작할 인덱스, 삭제할 요소 수)
// arr[1]부터 1개의 요소를 제거
arr.splice(1, 1);
console.log(arr); // [1, 3]

// length 프로퍼티가 자동 갱신된다.
console.log(arr.length); // 2
```

## 배열메서드
- mutator method : 원본배열을 직접변경
- accessor method : 원본을 복사한 새 배열을 생성하여 변경
    - 부수효과를 피하기위해 accessor method가 좋음
### Array.isArray
- Array 생성자함수의 정적메서드(Array.of, Array.from 처럼)
- 전달된 인수가 배열이면 true // 아니면 false
### Array.prototype.indexOf
- 원본배열에서 인수로 전달된 요소를 검색하여 인덱스 반환
    - 전달된 요소가 중복되는 여러개? : 첫번쨰로 검색된거 반환
    - 전달된 요소가 없어? : -1 반환
- 배열에 특정 요소가 존재하는지 확인할때 유용
    - ES7 도입된 Array.prototype.includes 메서드 사용이 better(찾아보기)
### Array.prototype.push
- 인수로 전달받은 모든값을 원본배열 마지막에 추가, 변경된 length 프로퍼티값 반환, 원본을 직접변경...부수효과 발생(한마디로 원본에 append해서 총길이 반환한다)
- ES6 스프레드문법이 better , 35.스프레드에서보기
### Array.prototype.pop
- 배열원본의 마지막요소 뽑기해서 반환..부수효과(원본이 빈배열? undefined)
    - 후입선출(LIFO) 방식의 stack 은 pop과 push로 쉽게 구현가능
### Array.prototype.unshift
- 전달받은 모든값을 원본배열의 선두에 추가, length 프로퍼티값 반환
    - 이것도 역시 부수효과떄문에 스프레드문법사용이 better
### Array.prototype.shift
- 원본배열의 첫번째 요소 제거, 제거한요소 반환(원본이 빈배열? undefined)
    - 선입선출(FIFO) 방식의 queue 는 shift와 push로 구현가능
### Array.prototype.concat
- 전달받은 값들을 원본배열을 복사한 새로운 배열에 마지막요소로 추가후 반환
    - 인수가 배열이면? 해체해서 원본배열에 요소로 추가  
```
차이를 잘 알아두자
push,unshift는 원본배열을 변경하므로 원본을 변수에 저장해야함  
그리고 배열을 인자로받으면 그냥 배열덩어리를 요소로 추가

concat은 반환값을 변수에 할당받아야함
배열을 인자로받으면 분해해서 요소로추가

하지만 결론은 push,unshift,concat 대신 ES6 스프레드 문법 써라
```
### Array.prototype.splice
- 원본을 직접변경, 배열의 중간에 요소 추가,제거 후 제거한 요소를 반환
- 매개변수 3개
    - start : start부터 모든요소를 제거하기 시작하는 인덱스(음수면 뒤에서부터)
    - deleteCount : start부터 제거할 요소의 갯수(옵션, 0이면 안지움)
    - items : 제거한 위치에 삽입할 요소들(옵션)
- indexOf 메서드로 요소의 인덱스를 파악한뒤, splice메서드 사용하면 배열내의 특정 요소를 제거할수 있음
- filter 메서드도 특정요소를 제거가능, but 특정요소가 중복되면 전부다지움
### Array.prototype.slice
- 인수로 전달된 범위의 요소들을 복사해서 배열로 반환
- 매개변수 2개
    - start : 복사를 시작할 인덱스 ( 음수면 뒤에서부터)
    - end : 복사를 종료할 인덱스 (생략가능/ 생략하면 끝가지지움, 이 인덱스에 해당하는값은 안지움 // start=1 end=3 이면 1,2까지만 지운다)
    - start,end 다없다? 그냥 통쨰로 복사해서 반환( 얕은 복사 )
    - 이걸 응용해서 arguments, NodeList 같은 유사배열객체를 배열로 변환
### Array.prototype.join
- 원본배열의 모든요로를 문자열로 변환, 인수로 받은 문자열(구분자)로 연결한 문자 반환
    - 구분자는 생략가능, default = , 콤마
    - 쉽게이해하자 1234 넣으면 1,2,3,4 나온다
### Array.prototype.reverse
- 원본배열 순서반대로 뒤집기, 원본을 변경해서 반환
### Array.prototype.fill
- ES6 인수로 전달받은값으로 배열의 처음부터 끝까지 다 채움(원본을)
    - 두번째 인수로 start지점 선택가능
    - 세번째 인수로 end 지점 선택가능(end처럼 end인덱스전까지 실행)
    - 하나의 인수로만 바꿀수있음,,,from메서드에 콜백함수넣어서쓰는게 better
### Array.prototype.includes
- ES7 배열내 특정요소 있으면 ture, 아니면 false
    - 첫번째 인수로 검색할요소
    - 두번째 인수로 start지점(생략시 0, 음수? length+음수 지점서 시작)
- indexOf메서드도 가능하지만, 반환값이 -1인지 확인해야되고 NaN의 존재여부는 확인불가능
### Array.prototype.flat
- ES10 인수의 깊이만큼 재귀적으로 배열을 평탄화
    - 무슨소리냐? 최상위스코프 아래부터 차례대로 벗긴다고 생각
- 중첩배열을 평탄화할 깊이를 인수로 전달가능, 기본값 1, Infinity 주면 중첩배열 전부 평탄화
```
// 중첩 배열을 평탄화하기 위한 깊이 값의 기본값은 1이다.
[1, [2, [3, [4]]]].flat();  // -> [1, 2, [3, [4]]]
[1, [2, [3, [4]]]].flat(1); // -> [1, 2, [3, [4]]]

// 중첩 배열을 평탄화하기 위한 깊이 값을 2로 지정하여 2단계 깊이까지 평탄화한다.
[1, [2, [3, [4]]]].flat(2); // -> [1, 2, 3, [4]]
// 2번 평탄화한 것과 동일하다.
[1, [2, [3, [4]]]].flat().flat(); // -> [1, 2, 3, [4]]

// 중첩 배열을 평탄화하기 위한 깊이 값을 Infinity로 지정하여 중첩 배열 모두를 평탄화한다.
[1, [2, [3, [4]]]].flat(Infinity); // -> [1, 2, 3, 4]
```

## 배열 고차함수
- 고차함수 : '함수를 인자로받거나 함수를 반환하는' 함수
    - 불변성 immutablility 지향하는 함수형 프로그래밍에 기반
    - 함수형 프로그래밍 ? 순수함수를 통해 부수효과를 최대한억제하는것

### Array.prototype.sort
- 원본의 요소를 집접 정렬시켜 정렬된 배열반환(timesort 알고리즘 사용)
    - 오름차순
    - 정렬된 배열.reverse()로 내림차순
    - 문자열 타입으로 임시 변환 후 유니코드 기반(숫자라도)
    - So 문자열 '10'은 유니코드 번호가 다른숫자들보다 빨라서 오류생김
    - 이걸 방지하기위해 숫자요소 정렬시 정렬 순서를 정의하는 비교함수를 인수로 전달 해야함(비교함수가 음수->첫번째먼저, 비교함수가 양수->두번째 먼저 정렬)
```
const points = [40, 100, 1, 5, 2, 25, 10];

// 여기서 화살표함수가 비교함수역할
// 숫자 배열의 오름차순 정렬 
points.sort((a, b) => a - b); // a-b가 음수네? 그럼 첫번쨰 1먼저 
console.log(points); // [1, 2, 5, 10, 25, 40, 100]

// 숫자 배열의 내림차순 정렬
points.sort((a, b) => b - a); 
console.log(points); // [100, 40, 25, 10, 5, 2, 1]
```
- 객체를 요소로갖는 배열 정렬법
    - 여기서는 비교함수를 산술이아닌 비교연산 임을 주의
```
const todos = [
  { id: 4, content: 'JavaScript' },
  { id: 1, content: 'HTML' },
  { id: 2, content: 'CSS' }
];

// 비교 함수. 매개변수 key는 프로퍼티 키다.
function compare(key) {
  // 프로퍼티 값이 문자열인 경우 - 산술 연산으로 비교하면 NaN이 나오므로 비교 연산을 사용한다.
  // 비교 함수는 양수/음수/0을 반환하면 되므로 - 산술 연산 대신 비교 연산을 사용할 수 있다.
  return (a, b) => (a[key] > b[key] ? 1 : (a[key] < b[key] ? -1 : 0));
}

// id를 기준으로 오름차순 정렬
todos.sort(compare('id'));
console.log(todos);
/*
[
  { id: 1, content: 'HTML' },
  { id: 2, content: 'CSS' },
  { id: 4, content: 'JavaScript' }
]
*/

// content를 기준으로 오름차순 정렬
todos.sort(compare('content'));
console.log(todos);
/*
[
  { id: 2, content: 'CSS' },
  { id: 1, content: 'HTML' },
  { id: 4, content: 'JavaScript' }
]
*/
```
### Array.prototype.forEach
- 원본을 바꾸지않지만, 의도적으로 콜백함수를통해 변경할수도 있음
- 내부에서 콜백함수로 전달받아 순회하며 반복호출(반복문 실행과 동일)
- 배열이 엄청많거나 시간복잡도가 높은 코드가 아니라면 for문대신 forEach사용
- forEach 메서드는 콜백함수에 세개의 인수를 전달
    - forEach 메서드를 호출한 배열의 요소값, 인덱스
    - forEach 메서드를 호출한 배열(this)
    - 여기서 this는 콜백함수내부 this가 아닌, forEach메서드 내부의 this
```
// forEach 메서드는 콜백 함수를 호출하면서 3개(요소값, 인덱스, this)의 인수를 전달한다.
// JSON.stringify 메서드는 객체를 JSON 포맷의 문자열로 변환
[1, 2, 3].forEach((item, index, arr) => {
  console.log(`요소값: ${item}, 인덱스: ${index}, this: ${JSON.stringify(arr)}`);
});
/*
요소값: 1, 인덱스: 0, this: [1,2,3]
요소값: 2, 인덱스: 1, this: [1,2,3]
요소값: 3, 인덱스: 2, this: [1,2,3]
*/
```
```
const numbers = [1, 2, 3];

// forEach 메서드는 원본 배열을 변경하지 않지만 콜백 함수를 통해 원본 배열을 변경할 수는 있다.
// 콜백 함수의 세 번째 매개변수 arr은 원본 배열 numbers를 가리킨다.
// 따라서 콜백 함수의 세 번째 매개변수 arr을 직접 변경하면 원본 배열 numbers가 변경된다.
numbers.forEach((item, index, arr) => { arr[index] = item ** 2; });
console.log(numbers); // [1, 4, 9]
```
- forEach 메서드의 반환값은 항상 undefined다 (why.....????)
    - 이 메서드의 활용이 하나의 값을얻기위한건 아니다 반복문을 돌리는게목적이지 ...그래서 언디파인드? 이해불가..
    - break 같은 마무리제어가 없어서 순회하다가 마지막에 없는값을 출력하는건가 ? 질문해봐야겠다..
- forEach 메서드의 두 번째 인수로 forEach 메서드의 콜백 함수 내부에서 this로 사용할 객체를 전달할 수 있다
    - 이때 두번쨰 인수로 전달하지않으면 ? 콜백함수가 일반함수로 호출되고 strict mode 때문에 undefined 참조해버림
    - but,,, 화살표함수 사용하면 자동으로 상위 this 참조하므로 훨씬간단
```
class Numbers {
  numberArray = [];

  multiply(arr) {
    // 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 참조한다.
    arr.forEach(item => this.numberArray.push(item * item));
  }
}

const numbers = new Numbers();
numbers.multiply([1, 2, 3]);
console.log(numbers.numberArray); // [1, 4, 9]
```
#### 폴리필 polyfill
- 낮은단계의 브라우저에서 누락된 최신기능을 구현해서 추가하는것
```
// 만약 Array.prototype에 forEach 메서드가 존재하지 않으면 폴리필을 추가한다.
if (!Array.prototype.forEach) {
  Array.prototype.forEach = function (callback, thisArg) {
    // 첫 번째 인수가 함수가 아니면 TypeError를 발생시킨다.
    if (typeof callback !== 'function') {
      throw new TypeError(callback + ' is not a function');
    }

    // this로 사용할 두 번째 인수를 전달받지 못하면 전역 객체를 this로 사용한다.
    thisArg = thisArg || window;

    // for 문으로 배열을 순회하면서 콜백 함수를 호출한다.
    for (var i = 0; i < this.length; i++) {
      // call 메서드를 통해 thisArg를 전달하면서 콜백 함수를 호출한다.
      // 이때 콜백 함수의 인수로 배열 요소, 인덱스, 배열 자신을 전달한다.
      callback.call(thisArg, this[i], i, this);
    }
  };
}
```
### Array.prototype.map
- 그리고 반환된 값들을 요소로하는 새로운 배열을 반환(원본은 유지)
- 요소값을 다른값으로 mapping한 새 배열을 생성하는 고차함수
    - 1:1 mapping 하므로 호출한 배열과 반환된배열의 length 값은 같다
- forEach와 동일하게 배열의요소값,인덱스,호출한배열(this)를 콜백함수에 전달하고, map 메서드의 두번쨰 인수로 콜백함수에 this로 사용할 객체전달가능
- 이것도 마찬가지로 화살표함수를 쓰는것이 best
```
class Prefixer {
  constructor(prefix) {
    this.prefix = prefix;
  }

  add(arr) {
    // 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 참조한다.
    return arr.map(item => this.prefix + item);
  }
}

const prefixer = new Prefixer('-webkit-');
console.log(prefixer.add(['transition', 'user-select']));
// ['-webkit-transition', '-webkit-user-select']
```
### Array.prototype.filter
- 반환값이 true 은 요소로만 구성된 배열반환
- 반환된배열의 length값이 원본보다 같거나 작다
- 다른특징들은 모두 forEach,map과 같다
- 역으로 응용하면 원하지않는 값을 선택해 제거할수있다(중복되면 중복된값이 다지워짐을 주의)
```
const numbers = [1, 2, 3, 4, 5];

// filter 메서드는 numbers 배열의 모든 요소를 순회하면서 콜백 함수를 반복 호출한다.
// 그리고 콜백 함수의 반환값이 true인 요소로만 구성된 새로운 배열을 반환한다.
// 다음의 경우 numbers 배열에서 홀수인 요소만을 필터링한다(1은 true로 평가된다).
const odds = numbers.filter(item => item % 2);
console.log(odds); // [1, 3, 5]
```
### Array.prototype.reduce
- 반환값을 다음 순회시에 콜백함수의 첫번째 인수로 전달하며 반복반복, 결국 하나의 값을 만들어 반환(원본유지)
- 첫번째인수는 콜백함수
- 두번째인수는 초기값
- 콜백함수에는 초기값or콜백함수 이전 반환값, reduce를 호출한 배열의 요소값,인덱스, reduce호출한배열(this)가 전달됨
- 평균값, 최대값, 요소중복횟수, 중첩배열평탄화, 중복요소제거 모두가능 but best는 아님
- 초기값은 생략가능하지만, 전달하는것이 better
    - 빈 배열이나 프로퍼티값을 합산할떄는 오류발생함.
```
const products = [
  { id: 1, price: 100 },
  { id: 2, price: 200 },
  { id: 3, price: 300 }
];

// 1번째 순회 시 acc는 { id: 1, price: 100 }, cur은 { id: 2, price: 200 }이고
// 2번째 순회 시 acc는 300, cur은 { id: 3, price: 300 }이다.
// 2번째 순회 시 acc에 함수에 객체가 아닌 숫자값이 전달된다. 이때 acc.price는 undefined다.
const priceSum = products.reduce((acc, cur) => acc.price + cur.price);

console.log(priceSum); // NaN
```
### Array.prototype.some
- 반환값이 한번이라도 참이면 true, 모두 거짓일때만 false
- 결과값을 불리언타입으로 반환/ 빈배열일땐 항상 false
### Array.prototype.evey
- 반환값이 한번이라도 거짓이면 false, 모두 참일때만 true
- 결과값을 불리언타입으로 반환/ 빈배열일땐 항상 true
### Array.prototype.find
- ES6 반환값이 true인 첫번째요소 반환/ 없으면 undefined
- 반환값이 배열이아닌 요소값임을 주의
### Array.prototype.findIndex
- ES6 반환값이 true인 첫번째요소의 인덱스를 반환/ 없으면 -1
### Array.prototype.flatMap
- ES10 map 메서드를통해 생성된 새로운배열을 평탄화
    - map메서드와 flat 메서드를 순차적으로쓰는것과 같은효과
- 단 flat과 다르게 깊이지정할수없고 **1단계만** 평탄화