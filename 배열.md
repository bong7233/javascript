# 배열 array
- 여러개의 값을 순차적으로 나열한 자료구조
    - 배열은 타입이아니다, 객체 타입 이다
- 배열 내부의 값 : 요소 element (값으로 인정하는 모든것은 요소로 가능)
    - element 는 자신의 배열내 위치를 나타내는 index 가짐
    - index 는 element 에 접근할때 사용 , 0부터 시작
- 배열은 length 프로퍼티(배열의 길이 나타냄) 가짐
    - length 프로퍼티, index 를 활용하여 반복문으로 요소에 순차적접근 가능 한것이 가장큰 장점
- 배열생성
    - 배열리터럴
    - Array 생성자함수
    - Array.of , Array.from 메서드
- 배열의 생성자함수는 Array
- 배열의 프로토타입객체는 Array.prototype
    - Array.prototype 은 배열을위한 빌트인 메서드 제공

- 일반객체와 배열의 차이
<table>
  <thead>
    <tr>
      <th style="text-align: left">구분</th>
      <th style="text-align: center">객체</th>
      <th style="text-align: center">배열</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">구조</td>
      <td style="text-align: center">프로퍼티 키와 프로퍼티 값</td>
      <td style="text-align: center">인덱스와 요소</td>
    </tr>
    <tr>
      <td style="text-align: left">값의 참조</td>
      <td style="text-align: center">프로퍼티 키</td>
      <td style="text-align: center">인덱스</td>
    </tr>
    <tr>
      <td style="text-align: left">값의 순서</td>
      <td style="text-align: center">x</td>
      <td style="text-align: center">○</td>
    </tr>
    <tr>
      <td style="text-align: left">length 프로퍼티</td>
      <td style="text-align: center">x</td>
      <td style="text-align: center">○</td>
    </tr>
  </tbody>
</table>
  
---
</br> 

## 자바스크립트의 배열은 일반적인 배열과 다르다
- 자료구조에서의 배열은 ***밀집배열(dense array)***  
동일한 크기의 메모리공간이 빈틈없이 연속적으로 나열된 구조. 배열의 요소는 하나의 데이터타입으로 통일, 연속적
    - index를 통해 한번의 연산으로 요소에접근가능, O(1)
    - 하지만 정렬되지않은 배열이면? 처음부터 linear serch 해야함 O(n)
    - 요소 삽입,삭제도 연속성유지를 위해 요소를 이동시켜야함...bad
- 자바스크립트에서의 배열은 ***희소배열 (saparse array)***  
각각의 메모리크기는 달라도되고 비연속적이여도 됨. 배열의 동작을 흉내낸 **특수한 객체**
- 쉽게 이해하는 자바스크립트 배열구조?
    - 배열의 인덱스를 나타내는 문자열 ('0', '1', '2' ...) : 프로퍼티 키
    - 배열의 요소 : 프로퍼티 값(어떤값이라도 들어올수있음)
    - length 프로퍼티 가짐
    - 해시테이블 구조, 속도는 느리지만 요소 삽입,삭제가 편리하고 빠름
    - 느린속도를 보완하기위해 모던자바스크립트 엔진들은 최적화시켜서 극복
---
</br>

## length 프로퍼티와 희소배열
- length 프로퍼티 : 요소의 갯수, 빈배열은 0, 빈배열 아니면 가장큰요소의 인덱스 +1 (0부터시작하기때문)
- length 의 maximun은 2의32승
- 요소 추가,삭제시 자동 갱신
- 임의의 숫자값을 명시적으로 할당도 가능
    - 프로퍼티보다 적은값을 할당하면 자동으로 줄어듬
    - 프로퍼티보다 큰값을 할당하면 배열의 길이는 그대로, 프로퍼티 값은 변경(이때 빈자리는 메모리확보하지않고 그냥 비워두고 empty로 알려줌)
```
const arr = [1, 2, 3, 4, 5];

// 현재 length 프로퍼티 값인 5보다 작은 숫자 값 3을 length 프로퍼티에 할당
arr.length = 3;

// 배열의 길이가 5에서 3으로 줄어든다.
console.log(arr); // [1, 2, 3]

// 더 많은수인 6을할당
arr.length = 6;
console.log(arr); // [1,2,3, <3 empty items> ]
```
- 결론은 배열의 요소가 비연속적이고 일부가 비어있다? = 희소배열  
그래서 length와 배열요소의 개수가 불일치, 정확히는 length는 희소배열의 실제 요소개수보다 항상 크다
    - 그래서 쓰지않을수록 좋다... 배열에는 같은타입요소를 연속위치하는게 best
---
</br>

## 배열생성
---
### 배열 리터럴
- 가장 normal, easy
- 0개 이상 요소를 쉼포로 구분, [] 묶음, 프로퍼티키 없고 값만있음
    - const arr = [1,2,3];
### Array 생성자함수
- new 연산자 없어도 내부의 new.target이 확인되어 생성자함수로 동작함
- 전달된 인수 갯수에따라 다르게 동작함을 주의
    - 전달 1개 and 숫자 : 인수를 length프로퍼티값(내용은 비어있는 희소배열)
    - 전달 X : 빈배열 [] 생성 (배열리터럴 []와 같음)
    - 전달 2개이상 or 숫자가 아니면 : 인수를 요소로
### Array.of
- 인수를 요소로갖는 배열생성(ES6 에서 도입)
    - 인수 갯수상관없음
### Array.from
- 유사배열객체 or 이터러블객체를 인수로 받아서 배열로 변환후 반환
```
// 유사 배열 객체를 변환하여 배열을 생성한다.
Array.from({ length: 2, 0: 'a', 1: 'b' }); // -> ['a', 'b']

// 이터러블을 변환하여 배열을 생성한다. 문자열은 이터러블이다.
Array.from('Hello'); // -> ['H', 'e', 'l', 'l', 'o']
```
- 두번째 인수에 콜백함수 전달하면 파이썬의 map과 같은 효과로 배열생성
```
// Array.from에 length만 존재하는 유사 배열 객체를 전달하면 undefined를 요소로 채운다.
Array.from({ length: 3 }); // -> [undefined, undefined, undefined]

// Array.from은 두 번째 인수로 전달한 콜백 함수의 반환값으로 구성된 배열을 반환한다.
Array.from({ length: 3 }, (_, i) => i); // -> [0, 1, 2]
```
- 이터러블객체  
Symbol.iterator 메서드로 for..of문을 사용해 순회가능하며 스프레드문법과 배열디스트럭처링할당의 대상으로 사용가능한 객체 (아직은 무슨뜻인지모름)

## 배열요소의 참조
- 배열요소 참조시 대괄호표기법[] 사용
    - 대괄호 안에는 인덱스
    - 정수로 평가되는 표현식이라면? 인덱스 대신사용 가능
    - 인덱스는 객체의 프로퍼티와 같은역할(값을 참조할수있음)
    - 존재하지않는 요소 접근? undefined

## 배열요소의 추가와 갱신
- 존재하지않는 인덱스를 사용, 값 할당하면 새로운 요소로 추가(length 프로퍼티 자동갱신)
    - length 보다 큰인덱스로 요소추가? 희소배열 됨
    - 기존 요소에 값 재할당하면 갱신
    - 인덱스요소를 정수가 아닌걸로 추가? 요소생성이 아니고 프로퍼티생성됨(이떄 추가된 프로퍼티는 length값에 영향주지않음)
```
const arr = [];

// 배열 요소의 추가
arr[0] = 1;
arr['1'] = 2;

// 프로퍼티 추가
arr['foo'] = 3;
arr.bar = 4;
arr[1.1] = 5;
arr[-1] = 6;

console.log(arr); // [1, 2, foo: 3, bar: 4, '1.1': 5, '-1': 6]

// 프로퍼티는 length에 영향을 주지 않는다.
console.log(arr.length); // 2
```
## 배열요소 삭제
- 배열은 객체다, 요소삭제는 delete 연산자로 가능
    - why? delete는 프로퍼티를 삭제하므로
    - but delete 사용하면 일반 배열도 희소배열이 되버림 bad
- So Array.prototype.splice 메서드 사용
```
const arr = [1, 2, 3];

// Array.prototype.splice(삭제를 시작할 인덱스, 삭제할 요소 수)
// arr[1]부터 1개의 요소를 제거
arr.splice(1, 1);
console.log(arr); // [1, 3]

// length 프로퍼티가 자동 갱신된다.
console.log(arr.length); // 2
```

## 배열메서드
- mutator method : 원본배열을 직접변경
- accessor method : 원본을 복사한 새 배열을 생성하여 변경
    - 부수효과를 피하기위해 accessor method가 좋음
### Array.isArray
- Array 생성자함수의 정적메서드(Array.of, Array.from 처럼)
- 전달된 인수가 배열이면 true // 아니면 false
### Array.prototype.indexOf
- 원본배열에서 인수로 전달된 요소를 검색하여 인덱스 반환
    - 전달된 요소가 중복되는 여러개? : 첫번쨰로 검색된거 반환
    - 전달된 요소가 없어? : -1 반환
- 배열에 특정 요소가 존재하는지 확인할때 유용
    - ES7 도입된 Array.prototype.includes 메서드 사용이 better(찾아보기)
### Array.prototype.push
- 인수로 전달받은 모든값을 원본배열 마지막에 추가, 변경된 length 프로퍼티값 반환, 원본을 직접변경...부수효과 발생(한마디로 원본에 append해서 총길이 반환한다)
- ES6 스프레드문법이 better , 35.스프레드에서보기
### Array.prototype.pop
- 배열원본의 마지막요소 뽑기해서 반환..부수효과(원본이 빈배열? undefined)
    - 후입선출(LIFO) 방식의 stack 은 pop과 push로 쉽게 구현가능
### Array.prototype.unshift
- 전달받은 모든값을 원본배열의 선두에 추가, length 프로퍼티값 반환
    - 이것도 역시 부수효과떄문에 스프레드문법사용이 better
### Array.prototype.shift
- 원본배열의 첫번째 요소 제거, 제거한요소 반환(원본이 빈배열? undefined)
    - 선입선출(FIFO) 방식의 queue 는 shift와 push로 구현가능
### Array.prototype.concat
- 전달받은 값들을 원본배열을 복사한 새로운 배열에 마지막요소로 추가후 반환
    - 인수가 배열이면? 해체해서 원본배열에 요소로 추가  
```
차이를 잘 알아두자
push,unshift는 원본배열을 변경하므로 원본을 변수에 저장해야함  
그리고 배열을 인자로받으면 그냥 배열덩어리를 요소로 추가

concat은 반환값을 변수에 할당받아야함
배열을 인자로받으면 분해해서 요소로추가

하지만 결론은 push,unshift,concat 대신 ES6 스프레드 문법 써라
```
### Array.prototype.splice
- 원본을 직접변경, 배열의 중간에 요소 추가,제거 후 제거한 요소를 반환
- 매개변수 3개
    - start : start부터 모든요소를 제거하기 시작하는 인덱스(음수면 뒤에서부터)
    - deleteCount : start부터 제거할 요소의 갯수(옵션, 0이면 안지움)
    - items : 제거한 위치에 삽입할 요소들(옵션)
- indexOf 메서드로 요소의 인덱스를 파악한뒤, splice메서드 사용하면 배열내의 특정 요소를 제거할수 있음
- filter 메서드도 특정요소를 제거가능, but 특정요소가 중복되면 전부다지움
### Array.prototype.slice
- 인수로 전달된 범위의 요소들을 복사해서 배열로 반환
- 매개변수 2개
    - start : 복사를 시작할 인덱스 ( 음수면 뒤에서부터)
    - end : 복사를 종료할 인덱스 (생략가능/ 생략하면 끝가지지움, 이 인덱스에 해당하는값은 안지움 // start=1 end=3 이면 1,2까지만 지운다)
    - start,end 다없다? 그냥 통쨰로 복사해서 반환( 얕은 복사 )
    - 이걸 응용해서 arguments, NodeList 같은 유사배열객체를 배열로 변환
### Array.prototype.join
- 원본배열의 모든요로를 문자열로 변환, 인수로 받은 문자열(구분자)로 연결한 문자 반환
    - 구분자는 생략가능, default = , 콤마
    - 쉽게이해하자 1234 넣으면 1,2,3,4 나온다
### Array.prototype.reverse
- 원본배열 순서반대로 뒤집기, 원본을 변경해서 반환
### Array.prototype.fill
- ES6 인수로 전달받은값으로 배열의 처음부터 끝까지 다 채움(원본을)
    - 두번째 인수로 start지점 선택가능
    - 세번째 인수로 end 지점 선택가능(end처럼 end인덱스전까지 실행)
    - 하나의 인수로만 바꿀수있음,,,from메서드에 콜백함수넣어서쓰는게 better
### Array.prototype.includes
- ES7 배열내 특정요소 있으면 ture, 아니면 false
    - 첫번째 인수로 검색할요소
    - 두번째 인수로 start지점(생략시 0, 음수? length+음수 지점서 시작)
- indexOf메서드도 가능하지만, 반환값이 -1인지 확인해야되고 NaN의 존재여부는 확인불가능
### Array.prototype.flat
- ES10 인수의 깊이만큼 재귀적으로 배열을 평탄화
    - 무슨소리냐? 최상위스코프 아래부터 차례대로 벗긴다고 생각
- 중첩배열을 평탄화할 깊이를 인수로 전달가능, 기본값 1, Infinity 주면 중첩배열 전부 평탄화
```
// 중첩 배열을 평탄화하기 위한 깊이 값의 기본값은 1이다.
[1, [2, [3, [4]]]].flat();  // -> [1, 2, [3, [4]]]
[1, [2, [3, [4]]]].flat(1); // -> [1, 2, [3, [4]]]

// 중첩 배열을 평탄화하기 위한 깊이 값을 2로 지정하여 2단계 깊이까지 평탄화한다.
[1, [2, [3, [4]]]].flat(2); // -> [1, 2, 3, [4]]
// 2번 평탄화한 것과 동일하다.
[1, [2, [3, [4]]]].flat().flat(); // -> [1, 2, 3, [4]]

// 중첩 배열을 평탄화하기 위한 깊이 값을 Infinity로 지정하여 중첩 배열 모두를 평탄화한다.
[1, [2, [3, [4]]]].flat(Infinity); // -> [1, 2, 3, 4]
```
