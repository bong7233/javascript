# 리터럴
실제 메모리에 저장되는 그 값들,혹은 값들이 저장되는 방식을 통칭 리터럴 이라함. 사람이 이해가능한 문자나 기호를 통해 값생성
변수에 해당하는 값 , 데이터자체이며 불변성을가진다
하지만 변수값=리터럴 이라는뜻이아닌 
객체는 변할수있는데 왜 객체리터럴이라 하는가? -> 리터럴한 객체라는게아니라 객체를 만드는방식을뜻한다
# 원시,객체타입
원시값은 불변성을가진 변수값.
프로퍼티들로 이뤄진 변수.
# 참조가능과 아닌것,참조에러
변수에 객체를 할당하면 객체를 저장하는것이아닌 객체를 메모리의공간에 할당한 후, 객체가 할당된 그 공간의 주소를 변수값으로 가진다. 이때 객체가 저장된 그 메모리고간을  참조값 reference value 라 한다. 이떄 이 객체는 변수가 참조가능하다
존재하지않는것 참조했을때 참조에러
# 가비지콜렉터
background 에서 데몬 쓰레드로 돌아가면서 접근 불가능한, 즉 주소를 알고있는 식별자가 없는 상태가 된 객체를 정리
mark-and-sweep’알고리즘: 전체루트를 쭉 내려가면서 객체들에 mark한다. 한바퀴돌았는데 mark되지않은건 sweep한다
깊게들어가면 generational(영올드)incremental(나눠서) idle-time(프로그램유휴상태일때)
모던자바스크립트엔진들에선 더 발전된형태의 가비지컬렉터사용
# 언매니지드 매니지드
매모리 관리방식에따라 나눠짐

# 표현식과 값
값으로 평가될수 있 모든 문(statement). 표현식이 평가되면 새로운값을 생성하거나 기존값을 참조한다.
# 선언과 정의 Declaration and Definition
선언은 그 선언한것에 들어갈 값에대한 메모리생성하지않음(선언자체의 메모리는있다)
정의는 선언한것에 값을 넣어서 메모리에 할당됨
컴파일러라면 선언전에 정의가되어있어야함.
인터프리터는..동시에가능한듯?
# null타입 사용
해당 변수의 없음을 나타내는 값(?), 전역식별자가 아님
즉 변수가 어떤 객체도 가르키고 있지않음.
undefined가 변수를 선언만해도 할당되지만, null은 자동할당이안된다..
값을 반환하지않는함수와 값은반환하지만 없는값을표현하는함수 구분가능
# 변수의 스코프
변수가 영향을 미치는 유효범위, 코드가 유효한범위
코드가 컴파일될때 RHS, LHS로 스코프를 구분하고 해당하는 변수목록을 작성함.
자바스크립트에서는 함수를 선언하면, 선언할떄마다 새로운 스코프를 생성함. 이떄 함수안에서만 접근가능한것을 함수스코프,지역스코프 라고한다
함수를 선언할때 {}로 둘러싸는데 이부분내에서 작용하는것을 블록스코프
이런것을떠나 함수나 {}외부에서 선언되어 전체에 영향을주는것은 global scope
# 전역변수 문제점
변수의 범위가너무넓고 접근제한이없어 오류발생이 많음. side effect가 있으면 문제 발생 소지가 큼  테스트시에도 하나의 변수의스코프가 너무넓으면 나눠서 테스트하기가 어려워짐.
# 단축평가
논리연산의 결과를 결정하는 피연산자를 타입변환없이 그대로 반환하며, 표현식을 평가하는 중 평가결과가 확정된다면 나머지 평가과정은 생략.
쉽게말해 둘중하나만 true여도 true가 성립되는 식이있을때, 하나만 체크했는데 이미 true다? 그럼 뒤에꺼는 신경안쓰고 바로 true 반환하는것
# 콜백함수
비동기처리 , 쉽게말해 어떤코드의 연산이끝나기전에 다른연산을 같이처리하는것(멀티스레드느낌)
이떄 발생하는 문제점을 처리하기위해 사용하는것이 콜백함수다.
a함수가 parameter로 b라는 콜백함수를 받는다.
b함수는 순서가오면 자동으로 실행되지않고 a함수가 실행되는동안 내가 원하는시점을 골라 그때 b함수를 쓸수있게되는것이다.
# 부수효과

#  symbol타입이 사용된 예시 —> 간략하게

# 블록문/코드블록

# 조건문(switch)

# 반복문

# break문

# continue문
