# 객체
- 자바스크립트는 객체기반 프로그래밍언어다(원시값을 제외한 모든것이 객체)
- 원시타입: 하나의 값 (mutalble value)
- 객체타입: 타입값들을 하나의 단위로 뭉친 복합자료구조 (immutable value)
    - 객체는 0개 이상의 프로퍼티로 구성되며, 프로퍼티는 키와 값으로 구성
    - 자바스크립트의 모든 값은 프로퍼티값이 될 수 있다
    - 함수는 일급객체이므로 값으로 취급된다(프로퍼티값으로쓰일 '메서드'라 함)
```
프로퍼티와 메서드
프로퍼티: 객체의 상태를 나타내는 값 data
메서드: 프로퍼티(상태데이터)를 참조,조작할수있는 동작 behavior

var counter = {
    num: 0,   <- 프로퍼티
    increase: function() {   <-메서드
        this.num++;          <-메서드
    }
}
```

## 객체리터럴에 의한 객체생성
- 자바스크립트는 프로토타입 기반 객체지향언어로 객체 생성방법이 다양하다.
    - 객체 리터럴
    - Object 생성자 함수
    - 생성자 함수
    - Object.create 메서드
    - 클래스 (ES6)

- 객체리터럴은 중괄호 {} 내에 0개이상 프로퍼티를 정의하고 , 변수에 할당이 이루어질때 자바스크립트 엔진이 객체리터럴을 해석하고 객체를 생성(중괄호가 비었으면 빈객체 생성)
```
var person = {
  name: 'Lee',
  sayHello: function () {
    console.log(`Hello! My name is ${this.name}.`);
  }
};
```

## 프로퍼티
- key 와 value로 구성, 프로퍼티 나열시 쉼표로 구분
    - key : 빈 문자열을 포함하는 모든 문자열 or 심벌 값(네이밍규칙 지키는게 best, 지키지않을시엔 ''로 묶어야해서 가독성,활용성 다 떨어짐)
    - value : 자바스크립트에서 사용가능한 모든 값

### key
- key는 문자열로 평가할수있는 표현식을 사용하여 동적 생성도 가능(빈문자열도 에러는 없지만, 의미가없으므로 사용하지않음)
- key가 문자열타입이 아닐때 -> 암묵적 타입변환-> 문자열타입으로 변환
- 동일한 key를 중복선언시 마지막 값이 덮어씌움
```
var obj = {};
var key = 'hello';

ES5: 프로퍼티 키 동적 생성
obj[key] = 'world';

ES6: 계산된 프로퍼티 이름
var obj = { [key]: 'world' };

console.log(obj); // {hello: "world"}
```

## 메서드
- 프로퍼티값이 함수일경우, 일반함수와 구분히기위해 method 라 부름(쉽게말해 객체안에 묶여있는함수는 method 다)
- 객체안의 this 키워드는 객체자신을 가르키는 참조변수이다.(파이썬의 self느낌)

## 프로퍼티 접근
- 마침표 표기법 dot notation : 마침표 프로퍼티 접근연산자 . 사용
- 대괄호 표기법 bracket notation : 대괄호 프로퍼티 접근연산자 [...] 사용
- key 가 네이밍규칙을 준수한다면, 두가지 모두 가능/ 비준수시 대괄호만 가능
- key 가 숫자로만 이뤄진 문자열이라면 []안의 따옴표 생략 가능
- 존재하지않는 프로퍼티에 접근하면 undefined 반환(ReferenceError 발생하지않음)
```
var person = {
  name: 'Lee'
};

// 마침표 표기법에 의한 프로퍼티 접근
console.log(person.name); // Lee

// 대괄호 표기법에 의한 프로퍼티 접근( 반드시 ''로 감싼 문자열이여야 함)
console.log(person['name']); // Lee
```

## 프로퍼티 삭제
- delete 연산자의 피연산자가 프로퍼티key에 접근가능한 표현식이여야 한다.
- 존재하지안흔 값이라면 에러없이 무시

---

# ES6 에서의 객체리터럴
- ES6에서 프로퍼티 값으로 변수를 사용시, 변수 이름과 프로퍼티 키가 동일하면 프로퍼티 키를 생략(property shorthand)할 수 있다. 이때 프로퍼티 키는 변수 이름으로 자동 생성된다.
```
// ES6
let x = 1, y = 2;

// 프로퍼티 축약 표현
const obj = { x, y };

console.log(obj); // {x: 1, y: 2}
```

- 계산된 프로퍼티이름 computed property name
    - key를 동적으로 생성시 [표현식] 으로 묶는것
    - ES5는 객체리터럴 외부에서 [...], ES6는 내부에서도 계산된 프로퍼티이름으로 동적생성 가능.
    ```
    // ES6
    const prefix = 'prop';
    let i = 0;

    // 객체 리터럴 내부에서 계산된 프로퍼티 이름으로 프로퍼티 키 동적 생성
    const obj = {
        [`${prefix}-${++i}`]: i,
        [`${prefix}-${++i}`]: i,
        [`${prefix}-${++i}`]: i
    };

    console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3}
    ```

- 메서드 축약표현
    - ES5 에서의 메서드 정의
    ```
    var obj = {
        name: 'Lee',
        sayHi: function() {
        console.log('Hi! ' + this.name);
        }
    };

    obj.sayHi(); // Hi! Lee
    ```
    - ES6 에서는 function 키워드 생략한 축약표현가능
    ```
    const obj = {
        name: 'Lee',
        // 메서드 축약 표현
        sayHi() {
            console.log('Hi! ' + this.name);
        }
    };

    obj.sayHi(); // Hi! Lee
    ```