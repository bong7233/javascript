# 변수의 생명주기
## 지역변수의 생명주기
- 전역변수의 생명은 애플리케이션의 생명과 같음/ 지역변수의 생명주기는 함수를 호출하면 생성, 함수가 종료하면 소멸
```
function foo() {
  var x = 'local';
  console.log(x); // local
  return x;
}

foo();
console.log(x); // ReferenceError: x is not defined
```
- 즉 생명주기는 메모리공간이 확보(allocate)->메모리공간해제(release)->가용메모리풀(memory pool)에 반환 까지의 시점이다

- 일반적으로 함수가종료하면 스코프도 소멸하지만, 다른곳에서 해당 스코프를 참조하고있다면, 해제되지않고 생존한다
## 전역변수 생명주기
- 전역변수의 생명주기는 전역 객체의 생명주기와 일치
```
전역 객체(global object)
전역 객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체다. 전역 객체는 클라이언트 사이드 환경(브라우저)에서는 window, 서버 사이드 환경(Node.js)에서는 global 객체를 의미한다. 환경에 따라 전역 객체를 가리키는 다양한 식별자(window, self, this, frames, global)가 존재했으나 ES11(ECMAScript 11)에서 globalThis로 통일되었다.
전역 객체에는 표준 빌트인 객체(Object, String, Number, Function, Array…)와 환경에 따른 호스트 객체(클라이언트 Web API 또는 Node.js의 호스트 API), 그리고 var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다.
전역 객체와 표준 빌트인 객체에 대해서는 “21. 빌트인 객체”에서 자세히 살펴보자.
```

# 전역변수의 문제점
- 암묵적 결합 : 모든 코드가 전역변수를 찾고 및 변경할수있음
- 긴 생명주기 : 메모리 리소스를 오랜기간 소비
- 스코프체인 최상단에 존재 : 전역변수를 검색하려면 맨위까지가야함 -> 검색 속도가 가장 느림
- 네임스페이스 오염 : 자바스크립트는 파일이 분리되어있어도 하나의 전역스코프를 공유 - > 예상치못한 전역변수 전역함수의 재할당,충돌
- So 전역변수를 써야할 확실한 이유가없다면 지역변수 사용, 변수의 스코프는 좁을수록 좋다
## 전역변수 사용억제법
- 즉시실행함수 : 모든 코드를 즉시실행함수로 감싸서 모든변수를 즉시실행함수의 지역변수로만듬.
- 네임스페이스객체 : 네임스페이스 역할을하는 객체를 만들어 변수를 프로퍼티형태로 추가하는방법 , 네임스페이스 객체자체가전역변수라서 효과가 별로...
- 모듈패턴 : 클로저를 이용하여 전역변수와 함수를 묶어 하나의 모듈을 만듬/ 억제 및 캡슐화까지 가능
## ES6 모듈
- ES6 모듈은 파일 자체의 독자적인 모듈스코프를 제공해 전역변수를 사용불가하게 만듦
