# 객체지향 프로그래밍 OOP
- 프로그램을 명령어나 함수의 목록으로 보는 명령형프로그래밍을 벗어나 여러개의 독립단위 객체(object)의 집합으로 프로그래밍을 표현하려는 패러다임
- 추상화 abstraction : 다양한 속성중 필요한속성만 간추려 표현하는것
- 객체 : 속성을 통해 여러개의 값을 하나의 단위로 구성한 복합적 자료구조
- 이때 객체지향 프로그래밍은 객체의 **상태(state)를 나타내는 데이터**, **상태 데이터를 조작할수있는 동작(behavior)**을 하나의 단위로 묶어서 생각함

## 상속과 프로토타입
- 상속 inheritance : OOP의 핵심개념, 객체의 프로퍼티나 메서드를 다른객체가 상속받아 그대로 사용할 수 있는것
- 자바스크립트는 프로토타입 기반으로 상속을 구현-> 불필요한 중복제거
    - 중복제거? 기존의 코드 재사용
- **프로토타입 기반의 상속**
```
// 생성자 함수
function Circle(radius) {
  this.radius = radius;
}

// Circle 생성자 함수가 생성한 모든 인스턴스가 getArea 메서드를
// 공유해서 사용할 수 있도록 프로토타입에 추가한다.
// 프로토타입은 Circle 생성자 함수의 prototype 프로퍼티에 바인딩되어 있다.
Circle.prototype.getArea = function () {
  return Math.PI * this.radius ** 2;
};

// 인스턴스 생성
const circle1 = new Circle(1);
const circle2 = new Circle(2);

// Circle 생성자 함수가 생성한 모든 인스턴스는 부모 객체의 역할을 하는
// 프로토타입 Circle.prototype으로부터 getArea 메서드를 상속받는다.
// 즉, Circle 생성자 함수가 생성하는 모든 인스턴스는 하나의 getArea 메서드를 공유한다.
console.log(circle1.getArea === circle2.getArea); // true

console.log(circle1.getArea()); // 3.141592653589793
console.log(circle2.getArea()); // 12.566370614359172
```
---

## 프로토타입 객체
- 프로토타입 객체(프로토타입)는 상속을 구현하기위해 사용
- 상속받은 자식은 상위객체의 프로퍼티를 자신의 프로퍼티처럼 사용가능
- 모든 객체는 [[Prototype]] 내부슬롯을 가지며 슬롯값이 프로토타입의 참조(null 일수도있음)다
    - 이는 객체가 생성될때 프로토타입객체 생성방식에의해 슬롯값이 결정됨
    - ex) 객체리터럴로 생성된 객체의 프로토타입 = Object.prototype  
    생성자함수로 생성된 객체의 프로토타입 =  생성자함수의 prototype 프로퍼티에 바인딩되어있는 객체
- 모든 객체는 하나의 프로토타입을 가지며 만약 내부슬롯의 값이 null이라면 프로토타입이 없는것이다
- 모든 프로토타입은 생성자함수와 연결되어있음

### __proto__ 접근자 프로퍼티
- 모든 객체는 __proto 접근자 프로퍼티로 자신의 프로토타입( [[Prototype]] 내부슬롯) 에 간접적으로 접근가능
- __proto__ 접근자 프로퍼티는 상속을 통해 사용된다
    - 객체가 직접 소유하는 프로퍼티가아닌 Object.prototype 의 프로퍼티고 모든 객체는 상속을 통해 Object.prototype.__proto__ 접근자 프로퍼티사용
    - 모든 객체는 프로토타입의 계층구조인 프로토타입 체인에 묶여있음
    - 자바스크립트 엔진은 객체프로퍼티에 접근할때 해당 객체에 접근하는 프로퍼티가없다면 ? __proto__ 접근자프로퍼티가 가르키는 참조를따라 부모프로토타입의 프로퍼티를 순차적으로 검색, 즉 프로토타입 체인의 최상위객체는 Object.prototype 이고 여기있는 프로퍼티와 메서드는 모든 하위객체에게 상속됨
- __proto__ 접근자프로퍼티로 프로토타입에 접근하는이유는?
    - 이는 상호참조로의해 프로토타입 체인이생성되는것을 방지하기위함
        - 쉽게말해 단방향 링크드리스트로 구현하기위함
        - 만약 부모와자식이 서로의 프로토타입이되버리는 순환참조가 되면 종점이없어 무한루프에 빠짐
- 코드 내에서는 __proto__ 접근자 프로퍼티를 사용하지않는것이 좋다
    - ES6 에서는 표준이지만 그전까진 비표준이였음
    - But 모든 객체가 Object.prototype을 상속받는게 아니기때문에 코드내에 사용했다가 참조하지못하는 상황발생
    - So Object.getPrototypeOf, Object.setPrototypeOf 메서드를 사용함
        - 이는 get Object.prototype.__proto__와 set Object.prototype.__proto__의 처리 내용과 동일
```
const obj = {};
const parent = { x: 1 };

// obj 객체의 프로토타입을 취득
Object.getPrototypeOf(obj); // obj.__proto__;
// obj 객체의 프로토타입을 교체
Object.setPrototypeOf(obj, parent); // obj.__proto__ = parent;

console.log(obj.x); // 1
```